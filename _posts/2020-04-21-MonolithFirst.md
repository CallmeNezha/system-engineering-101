---
layout: post
title: "MonolithFirst巨石优先"
description: '软件设计进化过程，总是由一个巨大的项目(巨石)逐渐拆简的过程。'
date:   2020-04-21 01:39:33 +0800
categories: microservices project planning evolutionary design process theory
by: '子健 江'
icon: 'navigation'
questions:
  - question: '采用微服务还是巨石应用？'
    answer: '1. 几乎所有成功的微服务都是从一个庞大的巨石项目开始，然后被成功分解了。 2. 几乎所有从头就直接上微服务的系统，它都最终陷入了严重的麻烦。'
  - question: '如何向微服务转变？'
    answer: '只有当你在服务之间找到良好，稳定的边界时(或称为网关)，微服务才能很好的工作起来，本质上这是软件已经发现并描绘了正确“上下文边界”集合的任务。'
---

当我听到有关使用**微服务架构**的团队的故事时，几乎总遵循一种常见的模式。

1. 几乎所有成功的微服务都是从一个庞大的巨石项目开始，然后被成功分解了。
2. 几乎所有从头就直接上微服务的系统，它都最终陷入了严重的麻烦。

这种模式的结论是：**即使你的应用最终将足够大到需要微服务的程度，你也不应该以微服务的形式启动你的新项目。**

![path.png](../assets/img/path.png)

微服务是一种有用的架构，但是即使是微服务的簇拥者都说使用它将会产生大量的**微服务溢价**，这意味着微服务仅在更复杂的系统中有用。这种溢价，实际上是管理一套服务的成本，将减慢团队的速度。这实际给了巨石优先(MonolithFirst)策略有力的论据支持，在巨石优先策略中，即使你认为以后可能会从微服务架构中受益，也应该最初以巨石形式构建新的应用程序。

第一个显然的原因是经典的***[Yagni](../Yagni)***。当你开始构建一个新应用时，你将如何确定它将对你的用户有用？扩展一个设计不佳但有效运行的软件系统可能非常困难，但是与反过来相比，这仍然是一个更好的选择。正如我们所认识到的那样，找出一个软件是否有用的最佳方法通常是通过构建一个最小可运行的简单版本并查看其效果如何，再考虑在重构时进行结构性调整。在这个最初阶段时，快速反馈的正循环才是你主要关心的，因此微服务的缺点是你应该避免的麻烦。

第二个问题是，只有当你在服务之间找到良好，稳定的边界时(或称为网关)，微服务才能很好的工作起来，本质上这是软件已经发现并描绘了正确“上下文边界”集合的任务。服务在且仅在“上下文边界”进行交互，而交互则需通过“网关”，网关可以看作是上下文边界的具体实现。但从以往经验中深刻意识到，任何服务之间的网关的功能重构都比在一个巨石应用中难处理的多。即使是一个熟悉领域工作的经验丰富的工程师也很难在一开始就能正确地确定边界。但通过构建一个巨石应用，你可以慢慢找到正确的边界，然后再将小块服务逐渐剥离出来。这种方式还使你有时间开发小块服务所需的环境条件。

合理的方法是精心设计一个巨石应用，同时注意软件在功能API边界和数据存储上的模块化。如果做到这一点，向微服务转变是自然而然的事情。

一种更常见的方法是从巨石应用中逐渐剥离边缘的微服务，使得应用的核心部分还是巨石，但在不断变化的更新发生在微服务之中，我们可以类比Linux系统的架构或符合OSGi的Eclipse插件式架构。

最后一种常见的做法是：完全重写，我把此种方法称为**牺牲式架构**。很少人对此表示骄傲，因为这意味着你写的全部代码将遭到废弃。但不要害怕这样做，或者至少不要认为这样做让你在他人眼里看起来很愚蠢，特别是如果第一个巨石应用可以快速的将你的业务推向市场。通常来说程序员不喜欢自己的辛苦劳动归零，特别是当团队经理决定废弃整个软件时。但请别忘了，正是牺牲式架构才成就了今天的新架构，也正是旧架构的牺牲，才领导了软件发展，考虑一下硬盘存储系统的发展历程，编译器的发展历程，操作系统的发展历程和网络框架的发展历程。

虽然绝大多数应用都适用“巨石优先”的开发方法，但这不一定完全正确。反对者认为，从微服务开始，你可以习惯微服务环境下的开发节奏。以足够模块化的方式构建巨石，并且可让单独的开发人员按服务边界分开进行独立开发。但这些都有一个非常强的前提条件，也就是团队具有构建微服务的合理经验与尽早的稳定服务边界，否则你不应该从微服务直接入手。一个合理的方法是首先由团队中具有足够领域经验的工程师构建出一个最小演示版本(通常是DEMO)后，逐步探索出服务边界并由不同开发者担任独立的API模块构建任务。最后逐步剥离API，向微服务的架构转变。